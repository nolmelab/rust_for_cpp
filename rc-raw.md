# Rc와 원시 포인터 

지금까지 우리는 고유 포인터(`Box<T>1)와 참조에 대해 다루었습니다. 고유 포인터는 C++의
새로운 `std::unique_ptr`과 매우 유사하며, 참조는 C++에서 포인터 또는 참조를 사용하는 경우 대부분 사용하는 '기본' 포인터입니다. Rust에는 라이브러리 내에 또는 언어 자체에 내장된 
몇 가지 더 드물게 사용되는 포인터 유형이 있습니다. 이들은 주로 C++에서 익숙한 여러 종류의
스마트 포인터와 유사합니다.

Rust가 많은 포인터 유형을 가지고 있는 것처럼 느껴질 수 있지만, 라이브러리에서 사용 가능한 
다양한 종류의 스마트 포인터를 생각해보면 C++과 꽤 유사합니다. 그러나 Rust에서는 언어를 
처음 배울 때 이러한 포인터 유형을 더 자주 만나게 됩니다. Rust 포인터는 컴파일러의 지원을
받기 때문에 사용할 때 실수를 할 가능성이 훨씬 적습니다.

러스트는 작은 역할 단위로 나눠서 해당 역할만 책임지도록 하는 방향으로 여러 언어 구성 요소도
설계되고 구현되었습니다. 따라서, 참조 (빌린 참조), `Box<T>`, `Rc<T>`, 원시 포인터, `Arc<T>`
와 같이 용도별 포인터가 있고, 처음 언어를 접할 때는 당황할 수도 있지만 익숙해지면 매우 
유용하다는 점을 알게 됩니다. [^1]

## Rc<T>

`Rc`는 참조 카운트를 갖는 포인터(Reference Counted 포인터)라는 뜻입니다.

참조 카운트를 갖는 포인터(Reference counted pointers)는 Rust 표준 라이브러리의 일부로
제공됩니다. `std::rc` 모듈에 포함되어 있습니다(모듈은 러스트의 파일 단위 구조화 기능입니다. 
예제에서의 `use` 문은 모듈을 사용하기 위한 것입니다). 타입 T의 객체에 대한 참조 카운트 
포인터는 `Rc<T>` 타입을 갖습니다.

`Rc::new(...)`라는 정적 메서드를 사용하여 참조 카운트 포인터를 생성합니다. C++의
`std::shared_ptr`과 비슷하지만 atomic 연산을 사용하지 않아 쓰레드 안전하지 않다는 차이만
있습니다. `Rc::new`를 호출한 후에는 포인터를 통해서만 값을 액세스할 수 있게 됩니다.

다른 포인터 타입과 마찬가지로 . 연산자는 필요한 모든 역참조를 수행합니다. 수동으로 역참조하기 위해 * 연산자를 사용할 수도 있습니다.

참조 카운트 포인터를 전달하려면 clone 메서드를 사용해야합니다. 이는 다소 불편한 점이며, 
향후 개선될 수 있지만 확실하지는 않습니다. 다행히도, 가리키는 값을 (빌린) 참조로 사용할 수 있으므로 자주 복제할 필요가 없을 것입니다. Rust의 타입 시스템은 참조가 만료되기 전에 참조 카운트 변수가 삭제되지 않도록 보장합니다. 참조를 취하는 것은 참조 카운트를 증가 또는 감소시킬 필요가 없으므로 성능이 향상됩니다. (하지만 이 차이는 아마도 미미할 것입니다. 왜냐하면 Rc 객체는 단일 스레드에 제한되므로 참조 카운트 연산은 원자적이지 않아도 됩니다). C++과 마찬가지로 Rc 포인터에 대한 참조도 가져올 수 있습니다.

Rc 예시:

```rust
use std::rc::Rc;

fn bar(x: Rc<i32>) { }
fn baz(x: &i32) { }

fn foo() {
    let x = Rc::new(45);
    bar(x.clone());   // 참조 카운트를 증가시킵니다.
    baz(&*x);         // 참조 카운트를 증가시키지 않습니다.
    println!("{}", 100 - *x);
}  // 이 스코프가 닫히면 모든 Rc 포인터가 사라지므로 참조 카운트는 0이 되고 
   // 메모리가 삭제됩니다.
```

참조 카운트 포인터는 항상 불변(immutable)입니다. 만약 가변(`mut`) 참조 카운트 객체를
사용하려면, `Rc`로 감싼 `RefCell` (또는 `Cell`)을 사용해야 합니다.

## `Cell`과 `RefCell`

`Cell`과 `RefCell`은 구조체로, 가변성 규칙을 '속일' 수 있게 해줍니다. 이를 설명하기 
위해서는 Rust의 데이터 구조와 가변성을 어떻게 다루는지에 대해 알아야 하기 때문에, 이런 약간 
까다로운 객체들은 나중에 다루도록 하겠습니다. 

일단, 가변 참조 카운트 객체를 원한다면 `Cell` 또는 `RefCell`을 `Rc`로 감싸야 함을 알아야
합니다. 첫 번째 근사값으로는, 원시 데이터에는 `Cell`을 사용하고, 이동 가능한 객체에는 
`RefCell`을 사용하는 것이 좋습니다. 따라서 가변한 참조 계수화된 정수를 원한다면 
`Rc<Cell<i32>>`를 사용하게 됩니다.

`Cell`과 `RefCell` 모두 내부 가변성을 제공하여 불변 변수나 참조에서도 내부 데이터를 
변경할 수 있도록 합니다. 둘의 차이는 `RefCell`의 경우 일반 변수의 빌림 규칙을 실행 시간에
검증하여 위반할 경우 패닉을 한다는 점입니다.  

## `*T` - 원시 포인터들

마지막으로, Rust에는 두 가지 종류의 원시 포인터 (또는 안전하지 않은 포인터)가 있습니다. `*const T`는 불변 원시 포인터를 나타내며, `*mut T`는 가변 원시 포인터를 나타냅니다. 이들은 
`&` 또는 `&mut`을 사용하여 생성할 수 있습니다. 

`&` 연산자는 대여된 참조나 원시 포인터 중 어떤 것을 생성할지 명시적으로 타입을 지정해야 할
수 있습니다. 원시 포인터는 C 포인터와 비슷하며, 제약이 없이 메모리를 가리키는 포인터입니다
(포인터 산술을 사용하려면 캐스팅이 필요하지만 필요한 경우 이 방법을 사용할 수 있습니다).

원시 포인터는 Rust에서 유일하게 널(null)일 수 있는 포인터 유형입니다. 원시 포인터에는
자동으로 간접 참조가 이루어지지 않으므로 (따라서 메서드를 호출하기 위해서는 (*x).foo()와
같이 작성해야 합니다), 자동으로 참조되지도 않습니다. 가장 중요한 제한은 비 안전 블록
외부에서 원시 포인터를 간접 참조(사용)할 수 없다는 것입니다. 일반적인 Rust 코드에서는 원시
포인터를 전달하는 것만 허용됩니다.

그렇다면, 무엇이 "unsafe" 코드인 걸까요? Rust는 강력한 안전성 보장을 가지고 있지만, 
(드물게) 필요한 작업을 수행할 수 없도록 제한할 때가 있습니다. Rust는 시스템 프로그래밍 
언어로서 모든 가능한 작업을 수행할 수 있어야 하기 때문에, 컴파일러가 안전성을 검증할 수 
없는 작업을 수행해야 할 때가 있습니다. 이를 위해 Rust에는 unsafe 키워드로 표시된 "unsafe" 블록 개념이 있습니다. 

"unsafe" 코드에서는 안전하지 않은 작업을 수행할 수 있습니다. 원시 포인터를 간접 참조하거나,
배열의 경계를 확인하지 않고 인덱스에 접근하거나, 외부 언어로 작성된 코드를 FFI를 통해
호출하거나, 변수를 캐스트하는 등의 작업이 가능합니다. 

당연히 "unsafe" 코드를 작성할 때에는 일반적인 Rust 코드를 작성할 때보다 훨씬 주의가 
필요합니다. 실제로, "unsafe" 코드를 작성하는 경우는 매우 드물며, 주로 라이브러리의 작은 
부분에 사용됩니다. "unsafe" 코드를 작성할 때는 Rust의 안전성을 보장하기 위해 일반적으로 
C++에서 수행하는 작업을 수동으로 수행해야 합니다. 또한, 일반적으로 컴파일러가 강제하는
불변성을 수동으로 유지해야 합니다. "unsafe" 블록은 Rust의 불변성을 수동으로 유지할 수 있게
해주지만, 이러한 불변성을 깨는 것은 허용하지 않습니다. 그렇게 하면 안전한 코드와 "unsafe"
코드 모두에서 버그를 도입할 수 있습니다.

원시 포인터를 사용하는 예시: 

```rust
fn foo() {
    let mut x = 5;
    let x_p: *mut i32 = &mut x;
    println!("x+5={}", add_5(x_p));
}

fn add_5(p: *mut i32) -> i32 {
    unsafe {
        if !p.is_null() { // Note that *-pointers do not auto-deref, so this is
                          // a method implemented on *i32, not i32.
            *p + 5
        } else {
            -1            // Not a recommended error handling strategy.
        }
    }
}
```

이로써 Rust의 포인터에 대한 여행을 마칩니다. 다음에는 포인터에서 잠시 쉬어가고, Rust의 데이터 구조에 대해 알아보겠습니다. 하지만 나중에 다시 참조에 대해서도 다룰 예정입니다.


[^1] 글을 쓸 때 글 자체에 대해 얘기하면 독자들을 산만하게 만들 수 있고, 글 자체에 대한 
신뢰에 부정적인 영향을 줄 수 있습니다. 따라서, 그러한 부분들은 번역에서 제외하고 
설명을 추가했습니다.