# 자료 구조

이번 글에서는 Rust의 데이터 타입에 대해 다루겠습니다. 이는 대체로 C++의 클래스, 구조체,
열거형과 유사합니다. Rust에서의 한 가지 차이점은 데이터와 동작이 C++(또는 Java나 다른 
객체 지향 언어)에 비해 훨씬 엄격하게 분리된다는 점입니다. 

동작은 함수에 의해 정의되며, 이러한 함수는 트레이트와 impl에서 정의할 수 있지만, 
트레이트에는 데이터를 포함할 수 없으며, 이 점에서 Java의 인터페이스와 유사합니다. 
트레이트와 impl에 대해서는 나중에 다룰 예정이므로, 이번 글에서는 데이터에 초점을 맞출
것입니다.

## struct (구조체)

Rust의 구조체는 C 구조체나 메서드가 없는 C++ 구조체와 유사합니다. 단순히 이름이 지정된 
필드들의 목록입니다. 구문은 다음 예시를 통해 가장 잘 이해할 수 있습니다:

```rust
struct S {
    field1: i32,
    field2: SomeOtherStruct
}
```

위 예시에서는 field1과 field2라는 두 개의 필드를 가진 S라는 구조체를 정의합니다. 필드들은
쉼표로 구분되며, 마지막 필드도 쉼표로 끝낼 수 있습니다.

구조체는 타입을 도입합니다. 예시에서는 S를 타입으로 사용할 수 있습니다. SomeOtherStruct는
다른 구조체로 가정되며, (C++과 마찬가지로) 값으로 포함되어 있으므로 메모리에서 다른 구조체
객체를 가리키는 포인터는 없습니다.

구조체의 필드는 `.` 연산자와 필드의 이름을 사용하여 접근됩니다. 구조체 사용의 예시입니다:

```rust
fn foo(s1: S, s2: &S) {
    let f = s1.field1;
    if f == s2.field1 {
        println!("field1 matches!");
    }
}
```

여기서 `s1`은 값으로 전달되는 구조체 객체이고 `s2`는 참조로 전달되는 구조체 객체입니다.
메서드 호출과 마찬가지로 두 경우 모두 필드에 접근하기 위해 동일한 `.`을 사용하며, `->`는
필요하지 않습니다.

구조체는 구조체 리터럴을 사용하여 초기화됩니다. 이는 구조체의 이름과 각 필드에 대한 값으로 
구성됩니다. 예를 들면 다음과 같습니다:

```rust
fn foo(sos: SomeOtherStruct) {
    let x = S { field1: 45, field2: sos };  // 구조체 리터럴을 사용하여 x를 초기화
    println!("x.field1 = {}", x.field1);
}
```

위의 예시에서 `x`는 구조체 리터럴을 사용하여 초기화되었습니다. `field1`의 값은 `45`이고 
`field2`는 `sos`의 값으로 설정되었습니다. `x.field1`의 값을 출력합니다.

구조체는 재귀적일 수 없습니다. 즉, 정의와 필드 유형을 포함하는 구조체 이름의 순환을 가질 
수 없습니다. 이는 구조체의 값 의미론 때문입니다. 따라서 예를 들어 
`struct R { r: Option<R> }`는 잘못되었으며 컴파일러 오류가 발생합니다 (Option에 대해서는
아래에서 더 자세히 설명합니다). 이러한 구조가 필요한 경우 포인터의 일종을 사용해야 합니다.
포인터를 사용하면 순환 구조가 허용됩니다:

```rust
struct R {
    r: Option<Box<R>>
}
```

위의 예시에서는 `Box<R>`을 사용하여 재귀적인 구조체를 생성하였습니다. `Box`는 힙에 
구조체를 할당하는 스마트 포인터입니다.

만약 위의 구조체에서 `Option`이 없다면, 해당 구조체를 인스턴스화할 수 있는 방법이 없으며
Rust는 오류를 표시할 것입니다.

필드가 없는 구조체는 정의나 리터럴 사용 시 중괄호를 사용하지 않습니다. 그러나 정의는 종결
세미콜론을 필요로 합니다. 아마도 구문 분석을 용이하게 하기 위해서인 것 같습니다.

```rust
struct Empty;

fn foo() {
    let e = Empty;
}
```
위의 예시에서 Empty는 필드가 없는 구조체로, 정의와 인스턴스화가 간단합니다.

## 튜플

튜플은 익명의 이질적인 데이터 시퀀스입니다. 타입으로서, 괄호 안에 타입의 시퀀스로 
선언됩니다. 이름이 없기 때문에 구조에 의해 식별됩니다. 예를 들어, 타입 (i32, i32)은 
정수의 쌍을 의미하며 (i32, f32, S)는 트리플입니다. 튜플 값은 타입을 선언하는 방식과 
동일하게 초기화됩니다. 다만 구성 요소에 값이 사용됩니다. 예를 들면 (4, 5)입니다. 아래는
예시입니다.

```rust
// foo는 구조체를 인자로 받아 튜플을 반환합니다.
fn foo(x: SomeOtherStruct) -> (i32, f32, S) {
    (23, 45.82, S { field1: 54, field2: x })
}
```

튜플은 let 표현식을 사용하여 디스트럭처링을 통해 사용할 수 있습니다. 예를 들어,

```rust
fn bar(x: (i32, i32)) {
    let (a, b) = x;
    println!("x was ({}, {})", a, b);
}
```

튜플의 값은 디스트럭처링 외에 `.`으로 순서를 지정하여 접근할 수 있습니다. 

```rust
fn bar_another(x: (i32, i32)) {
    println!("x was ({}, {})", x.0, x.1);
}
```

다음 시간에는 디스트럭처링에 대해 더 자세히 이야기하겠습니다.


## 튜플 구조체

튜플 구조체는 이름이 지정된 튜플 또는 이름이 없는 필드를 가진 구조체입니다. struct 키워드,
괄호 안의 타입 목록 및 세미콜론을 사용하여 선언됩니다. 이러한 선언은 해당 이름을 타입으로 
소개합니다. 필드에는 이름 대신 디스트럭처링을 통해 접근해야 합니다 (튜플과 유사한 방식).
튜플 구조체는 그리 흔하지 않습니다.

```rust
struct IntPoint(i32, i32);

fn foo(x: IntPoint) {
    let IntPoint(a, b) = x;  // 튜플 구조체의 이름이 디스트럭처링에 필요합니다.
    println!("x was ({}, {})", a, b);
}
```

튜플 구조체는 구조체와 enum만 메서드 구현을 갖기 떄문에 튜플에 메서드를 제공하기위한 
우회 기법입니다. 또 빠르게 뭔가를 실험하고자 할 때 사용합니다.

## enum (열거형)j

열거형(Enum)은 C++의 열거형 또는 공용체와 같은 타입으로, 여러 가지 값을 가질 수 있는 
타입입니다. 가장 간단한 종류의 열거형은 C++의 열거형과 비슷합니다.

```rust
enum E1 {
    Var1,
    Var2,
    Var3
}

fn foo() {
    let x: E1 = E1::Var2;
    match x {
        E1::Var2 => println!("var2"),
        _ => {}
    }
}
```

그러나 Rust의 열거형은 그보다 훨씬 강력합니다. 각각의 변형(variant)은 데이터를 포함할 수
있습니다. 튜플과 마찬가지로, 이들은 유니온(union)과 같은 개념이며, C++의 열거형과는
다릅니다. Rust의 열거형은 태그가 있는 유니온(tagged union)입니다. 즉, 런타임에서 하나의
변형을 다른 변형으로 오해할 수 없습니다[^1]. 예시를 살펴보겠습니다:

```rust
enum Expr {
    Add(i32, i32),
    Or(bool, bool),
    Lit(i32)
}

fn foo() {
    let x = Or(true, false);   // x의 타입은 Expr입니다
}
```

Rust에서는 많은 경우에 간단한 객체 지향 다형성을 열거형을 사용하여 더 잘 처리할 수 
있습니다. 열거형을 활용하면 코드를 더 유연하고 안전하게 작성할 수 있습니다.

Rust에서는 열거형을 정의할 때 각 변형(variant)은 데이터를 포함할 수 있습니다. 각 변형은 
변형 이름으로 시작하고, 괄호 안에 포함될 수 있는 데이터의 타입을 지정하여 정의됩니다. 위의
예시에서 Expr 열거형은 Add, Or, Lit 세 가지 변형을 가지고 있습니다. 각 변형은 다른 타입의
데이터를 포함할 수 있습니다. 예를 들어, Add 변형은 두 개의 i32 값, Or 변형은 두 개의 bool
값, Lit 변형은 하나의 i32 값을 포함합니다.

Rust의 열거형은 하나의 타입 내에서 다양한 경우나 상태를 처리하는 강력한 메커니즘을
제공합니다. 열거형은 계산 중에 다양한 가능성이나 결과를 표현하는 데 자주 사용되며, 이를 
통해 코드를 더 표현적이고 간결하게 만들 수 있습니다.

열거형을 사용할 때 일반적으로 match 표현식을 사용합니다. 이는 C++의 switch 문과 
유사합니다. 다음에 더 자세히 다루겠지만, 데이터를 분해하는 다른 방법들도 소개할 예정입니다.
다음은 예시입니다:

```rust
fn bar(e: Expr) {
    match e {
        Add(x, y) => println!("`Add` 변형: {} + {}", x, y),
        Or(..) => println!("`Or` 변형"),
        _ => println!("다른 변형 (이 경우 `Lit` 변형)"),
    }
}
```
`match` 표현식의 각 분기는 `Expr`의 변형과 일치합니다. 모든 변형을 다루어야 합니다. 마지막
case (_)는 나머지 모든 변형을 다루는 것으로, 예시에서는 `Lit`만 존재합니다. 변형의 데이터는
변수에 바인딩될 수 있습니다. Add 분기에서는 Add 내의 두 개의 i32 값을 x와 y에 바인딩하고
있습니다. 데이터에 관심이 없다면 ..를 사용하여 모든 데이터와 일치시킬 수 있습니다. `Or`의
경우와 같습니다. 

## Option 열거형

Rust에서 흔히 사용되는 열거형 중 하나는 `Option`입니다. 이는 `Some`과 `None`이라는 두 가지
변형을 갖습니다. `None`은 데이터가 없고 `Some`은 `T` 타입의 단일 필드를 가지고 있습니다.
(Option은 제네릭 열거형으로, 이후에 다룰 예정이지만, 아마도 C++에서의 제네릭 개념은
알고 있을 것입니다). 

`Option`은 값이 있을 수도 있고 없을 수도 있다는 것을 나타내는 데 사용됩니다. C++에서 널
포인터를 사용하여 어떤 방식으로든 정의되지 않거나 초기화되지 않은 값을 나타내는 경우에는
Rust에서 `Option`을 사용하는 것이 좋습니다. `Option`을 사용하면 안전성이 향상되는데,
사용하기 전에 항상 확인해야 하기 때문에 널 포인터를 역참조하는 것과 같은 동작을 할 수
없습니다. 또한 더 일반적으로 사용할 수 있으며, 포인터뿐만 아니라 값과 함께 사용할 수
있습니다. 예시입니다:

```rust
use std::rc::Rc;

struct Node {
    parent: Option<Rc<Node>>,
    value: i32
}

fn is_root(node: Node) -> bool {
    match node.parent {
        Some(_) => false,
        None => true
    }
}
```

여기서 `parent` 필드는 `None`이거나 `Rc<Node>`를 포함하는 `Some`일 수 있습니다. 이
예시에서는 실제로 해당 필드를 사용하지 않지만, 실제 상황에서는 일반적으로 사용됩니다.

`Option`에는 편의 메서드도 있으므로 `is_root`의 본문을 `node.parent.is_none()` 또는
`!node.parent.is_some()`으로 작성할 수도 있습니다.

## 상속된 가변성과 `Cell`/`RefCell`

Rust에서 로컬 변수는 기본적으로 변경할 수 없으며 mut을 사용하여 변경 가능하게 표시할 수 
있습니다. 구조체나 열거형의 필드는 변경 가능성이 상속됩니다. 즉, 구조체 객체의 필드는 해당
객체 자체가 변경 가능하거나 변경할 수 없는지에 따라 변경 가능하거나 변경할 수 없습니다. 

예시:

```rust
struct S1 {
    field1: i32,
    field2: S2
}
struct S2 {
    field: i32
}

fn main() {
    let s = S1 { field1: 45, field2: S2 { field: 23 } };
    // s는 변경할 수 없으므로 다음 변경은 허용되지 않습니다.
    // s.field1 = 46;
    // s.field2.field = 24;

    let mut s = S1 { field1: 45, field2: S2 { field: 23 } };
    // s는 변경 가능하므로 다음 변경은 허용됩니다.
    s.field1 = 46;
    s.field2.field = 24;
}
```

Rust에서 상속된 가변성은 참조에서 멈춥니다. 이는 C++에서 `const` 객체의 포인터를 통해 
비-`const` 객체를 수정할 수 있는 것과 유사합니다. 참조 필드를 변경 가능하게 하려면 필드
 유형에 `&mut`을 사용해야 합니다.

```rust
struct S1 {
    f: i32
}
struct S2<'a> {
    f: &'a mut S1   // 변경 가능한 참조 필드
}
struct S3<'a> {
    f: &'a S1       // 변경 불가능한 참조 필드
}

fn main() {
    let mut s1 = S1{f:56};
    let s2 = S2 { f: &mut s1};
    s2.f.f = 45;   // s2는 변경할 수 없더라도 합법적입니다.
    // s2.f = &mut s1; // 합법적이지 않습니다. - s2는 변경할 수 없음
    let s1 = S1{f:56};
    let mut s3 = S3 { f: &s1};
    s3.f = &s1;     // 합법적입니다. - s3는 변경 가능함
    // s3.f.f = 45; // 합법적이지 않습니다. - s3.f는 변경할 수 없음
}
```

(`S2`와 `S3`의 `'a` 매개변수는 라이프타임 매개변수이며, 곧 다룰 예정입니다).

가끔은 논리적으로 불변인 객체도 내부적으로 변경 가능한 부분이 필요한 경우가 있습니다.
캐싱이나 참조 횟수 계산 등을 생각해보세요. 이러한 경우 C++에서는 `mutable` 키워드를 사용하여
객체가 `const`인 상태에서도 해당 부분을 변경할 수 있게 합니다. Rust에서는 `Cell`과 
`RefCell` 구조체를 사용합니다. 이들을 사용하면 불변 객체의 일부를 변경할 수 있습니다. 
이는 유용하지만, Rust에서 불변 객체를 볼 때 일부 부분이 실제로는 변경 가능할 수 있다는 
점을 인식해야 한다는 것을 의미합니다.

`RefCell`과 `Cell`을 사용하면 Rust의 엄격한 변경 규칙과 별칭 규칙을 우회할 수 있습니다.
이들은 러스트의 불변성이 동적으로 존중되도록 보장하기 때문에 사용이 안전합니다. 그러나
컴파일러는 이러한 불변성을 정적으로 확인할 수 없기 때문에 동적으로 확인합니다. `Cell`과
`RefCell`은 단일 스레드 환경에서 사용하는 객체입니다.

`Cell`은 복사(Copy) 의미론을 가진 타입(주로 기본 타입)에 사용됩니다. `Cell`은 저장된 값을
변경하기 위한 `get`과 `set` 메서드, 그리고 값을 초기화하기 위한 `new` 메서드를 제공합니다.
`Cell`은 매우 간단한 객체입니다. 왜냐하면 복사 의미론을 가진 객체는 (러스트에서) 다른 곳에
참조를 유지할 수 없고, 다른 스레드 간에 공유할 수 없기 때문에 문제가 발생할 여지가 없기
때문입니다.

`RefCell`은 이동(Semantics) 의미론을 가진 타입에 사용됩니다. 이는 거의 모든 러스트의 
타입을 포함하며, 구조체 객체는 일반적인 예입니다. `RefCell`도 `new`를 사용하여 생성되며, 
`set` 메서드를 가지고 있습니다. `RefCell`에서 값을 가져오려면 `borrow` 메서드 (`borrow`,
`borrow_mut`, `try_borrow`, `try_borrow_mut`)를 사용하여 대여(reference)해야 합니다. 

이 메서드들은 정적 대여 규칙과 동일한 규칙을 따릅니다. 즉, 하나의 가변 대여(mutably borrow)
만 가능하며, 동시에 가변 참조와 불변 참조를 동시에 할 수는 없습니다. 그러나 컴파일 오류 
대신 실행 시간 오류가 발생합니다. try_ 접두사가 있는 변형들은 `Option`을 반환합니다. 값이
대여될 수 있는 경우 `Some(val)`이 반환되고, 그렇지 않은 경우 `None`이 반환됩니다. 값이
이미 참조된 경우 `set`을 호출해도 실패합니다.

아래는 RefCell에 대해 참조 카운트를 갖는 포인터를 사용하는 예시입니다: 

```rust
use std::rc::Rc;
use std::cell::RefCell;

struct S {
    field: i32
}

fn foo(x: Rc<RefCell<S>>) {
    {
        let s = x.borrow();
        println!("the field, twice {} {}", s.field, x.borrow().field);
        // let s = x.borrow_mut(); // Error - we've already borrowed the contents of x
    }

    let mut s = x.borrow_mut(); // OK, the earlier borrows are out of scope
    s.field = 45;
    // println!("The field {}", x.borrow().field); // Error - can't mut and immut borrow
    println!("The field {}", s.field);
}

fn main() {
    let s = S{field:12};
    let x: Rc<RefCell<S>> = Rc::new(RefCell::new(s));
    foo(x.clone());

    println!("The field {}", x.borrow().field);
}
```

Cell과 RefCell은 가능한 한 작은 범위에서 사용해야 합니다. 즉, 전체 구조체 대신 몇 개의
필드에 적용하는 것이 좋습니다. 이는 단일 스레드 락과 유사한 개념으로, 더 작은 단위로 락을
설정하면 충돌할 가능성이 줄어듭니다.

Cell과 RefCell은 변경 가능성을 가진 데이터에 대한 민감한 영역에 선택적으로 적용하는 것이
일반적으로 권장됩니다. 구조체 전체 대신 개별적인 필드에 적용함으로써 더 세밀한 제어를 할 
수 있으며, 변경 가능한 데이터에 대한 동시 액세스 시 충돌이나 간섭을 최소화할 수 있습니다.

상호 배제를 위한 단일 스레드 락과 유사한 개념으로 생각해 보세요. `Cell`과 `RefCell`을 특정
필드에 선택적으로 적용함으로써 변경 가능한 상태를 효과적으로 분리하고 관리할 수 있으며,
데이터 구조의 서로 다른 부분에 동시 접근이 제한되지 않도록 합니다.


[^1]: C++17에서는 Rust의 열거형에 더 가까운 `std::variant<T>` 타입이 있습니다. 이는 C++의
`union`보다는 Rust의 `enum`와 더 비슷합니다.

[^2]: C++17부터 `std::optional<T>`은 Rust `Option`의 가장 적합한 대안입니다.


